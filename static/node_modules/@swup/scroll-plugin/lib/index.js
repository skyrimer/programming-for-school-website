'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _plugin = require('@swup/plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _scrl = require('scrl');

var _scrl2 = _interopRequireDefault(_scrl);

var _helpers = require('swup/lib/helpers');

var _utils = require('swup/lib/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class representing a Scroll Plugin.
 * @extends Plugin
 */
var ScrollPlugin = function (_Plugin) {
	_inherits(ScrollPlugin, _Plugin);

	/**
  * Constructor
  * @param {?object} options the plugin options
  */
	function ScrollPlugin(options) {
		_classCallCheck(this, ScrollPlugin);

		var _this = _possibleConstructorReturn(this, (ScrollPlugin.__proto__ || Object.getPrototypeOf(ScrollPlugin)).call(this));

		_this.name = 'ScrollPlugin';

		_this.getAnchorElement = function () {
			var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

			// Look for a custom function provided via the plugin options
			if (typeof _this.options.getAnchorElement === 'function') {
				return _this.options.getAnchorElement(hash);
			}
			// Look for a the built-in function in swup, added in swup 2.0.16
			if (typeof _this.swup.getAnchorElement === 'function') {
				return _this.swup.getAnchorElement(hash);
			}
			// Finally, return a native browser query
			return document.querySelector(hash);
		};

		_this.getOffset = function () {
			var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

			// If options.offset is a function, apply and return it
			if (typeof _this.options.offset === 'function') {
				return parseInt(_this.options.offset(element), 10);
			}
			// Otherwise, return the sanitized offset
			return parseInt(_this.options.offset, 10);
		};

		_this.onSamePage = function () {
			_this.swup.scrollTo(0, _this.shouldAnimate('samePage'));
		};

		_this.onSamePageWithHash = function (event) {
			var link = event.delegateTarget;
			_this.maybeScrollToAnchor(link.hash, 'samePageWithHash');
		};

		_this.onTransitionStart = function (popstate) {
			if (_this.options.doScrollingRightAway && !_this.swup.scrollToElement) {
				_this.doScrollingBetweenPages(popstate);
			}
		};

		_this.onContentReplaced = function (popstate) {
			if (!_this.options.doScrollingRightAway || _this.swup.scrollToElement) {
				_this.doScrollingBetweenPages(popstate);
			}

			_this.restoreScrollContainers(popstate);
		};

		_this.doScrollingBetweenPages = function (popstate) {
			var swup = _this.swup;

			// Bail early on popstate and inactive `animateHistoryBrowsing`
			if (popstate && !swup.options.animateHistoryBrowsing) {
				return;
			}

			// Try scrolling to a given anchor
			if (_this.maybeScrollToAnchor(swup.scrollToElement, 'betweenPages')) {
				swup.scrollToElement = null;
				return;
			}

			// Finally, scroll to either the stored scroll position or to the very top of the page
			var scrollPositions = _this.getStoredScrollPositions(_this.getCurrentCacheKey()) || {};
			var top = scrollPositions.window && scrollPositions.window.top || 0;
			// Give possible JavaScript time to execute before scrolling
			requestAnimationFrame(function () {
				return swup.scrollTo(top, _this.shouldAnimate('betweenPages'));
			});
		};

		_this.onWillReplaceContent = function () {
			_this.storeScrollPositions(_this.currentCacheKey);
			_this.currentCacheKey = _this.getCurrentCacheKey();
		};

		_this.onClickLink = function (event) {
			_this.maybeResetScrollPositions(event.delegateTarget);
		};

		var defaultOptions = {
			doScrollingRightAway: false,
			animateScroll: {
				betweenPages: true,
				samePageWithHash: true,
				samePage: true
			},
			scrollFriction: 0.3,
			scrollAcceleration: 0.04,
			getAnchorElement: null,
			offset: 0,
			scrollContainers: '[data-swup-scroll-container]',
			shouldResetScrollPosition: function shouldResetScrollPosition(htmlAnchorElement) {
				return true;
			}
		};

		_this.options = _extends({}, defaultOptions, options);
		return _this;
	}

	/**
  * Runs if the plugin is mounted
  */


	_createClass(ScrollPlugin, [{
		key: 'mount',
		value: function mount() {
			var _this2 = this;

			var swup = this.swup;

			// add empty handlers array for scroll events
			swup._handlers.scrollDone = [];
			swup._handlers.scrollStart = [];

			// Initialize Scrl for smooth animations
			this.scrl = new _scrl2.default({
				onStart: function onStart() {
					return swup.triggerEvent('scrollStart');
				},
				onEnd: function onEnd() {
					return swup.triggerEvent('scrollDone');
				},
				onCancel: function onCancel() {
					return swup.triggerEvent('scrollDone');
				},
				friction: this.options.scrollFriction,
				acceleration: this.options.scrollAcceleration
			});

			// set scrollTo method of swup and animate based on current animateScroll option
			swup.scrollTo = function (offset) {
				var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

				if (animate) {
					_this2.scrl.scrollTo(offset);
				} else {
					swup.triggerEvent('scrollStart');
					window.scrollTo(0, offset);
					swup.triggerEvent('scrollDone');
				}
			};

			// This object will hold all scroll positions
			this.scrollPositionsStore = {};
			// this URL helps with storing the current scroll positions on `willReplaceContent`
			this.currentCacheKey = this.getCurrentCacheKey();

			// disable browser scroll control on popstates when
			// animateHistoryBrowsing option is enabled in swup.
			// Cache the previous setting to be able to properly restore it on unmount
			this.previousScrollRestoration = window.history.scrollRestoration;
			if (swup.options.animateHistoryBrowsing) {
				window.history.scrollRestoration = 'manual';
			}

			// scroll to the top of the page
			swup.on('samePage', this.onSamePage);

			// scroll to referenced element on the same page
			swup.on('samePageWithHash', this.onSamePageWithHash);

			// scroll to the referenced element
			swup.on('transitionStart', this.onTransitionStart);

			// scroll to the referenced element when it's in the page (after render)
			swup.on('contentReplaced', this.onContentReplaced);

			swup.on('willReplaceContent', this.onWillReplaceContent);
			swup.on('clickLink', this.onClickLink);
		}

		/**
   * Runs when the plugin is unmounted
   */

	}, {
		key: 'unmount',
		value: function unmount() {
			var swup = this.swup;
			swup.scrollTo = null;

			delete this.scrl;
			this.scrl = null;

			swup.off('samePage', this.onSamePage);
			swup.off('samePageWithHash', this.onSamePageWithHash);
			swup.off('transitionStart', this.onTransitionStart);
			swup.off('contentReplaced', this.onContentReplaced);
			swup.off('willReplaceContent', this.onWillReplaceContent);
			swup.off('clickLink', this.onClickLink);

			swup._handlers.scrollDone = null;
			swup._handlers.scrollStart = null;

			window.history.scrollRestoration = this.previousScrollRestoration;
		}

		/**
   * Detects if a scroll should be animated, based on context
   * @param {string} context
   * @returns {boolean}
   */

	}, {
		key: 'shouldAnimate',
		value: function shouldAnimate(context) {
			if (typeof this.options.animateScroll === 'boolean') {
				return this.options.animateScroll;
			}
			return this.options.animateScroll[context];
		}

		/**
   * Get an element based on anchor
   * @param {string} hash
   * @returns {mixed}
   */


		/**
   * Get the offset for a scroll
   * @param {(HtmlELement|null)} element
   * @returns {number}
   */


		/**
   * Handles `samePage`
   */


		/**
   * Handles `onSamePageWithHash`
   * @param {PointerEvent} event
   */

	}, {
		key: 'maybeScrollToAnchor',


		/**
   * Attempts to scroll to an anchor
   * @param {string} hash
   * @param {string} context
   * @returns {boolean}
   */
		value: function maybeScrollToAnchor(hash, context) {
			// Bail early if the hash is null
			if (hash == null) {
				return false;
			}
			var element = this.getAnchorElement(hash);
			if (!element) {
				console.warn('Element ' + hash + ' not found');
				return false;
			}
			if (!(element instanceof Element)) {
				console.warn('Element ' + hash + ' is not a DOM node');
				return false;
			}
			var top = element.getBoundingClientRect().top + window.pageYOffset - this.getOffset(element);
			this.swup.scrollTo(top, this.shouldAnimate(context));
			return true;
		}

		/**
   * Handles `transitionStart`
   * @param {PopStateEvent} popstate
   */


		/**
   * Handles `contentReplaced`
   * @param {PopStateEvent} popstate
   */


		/**
   * Scrolls the window, based on context
   * @param {(PopStateEvent|boolean)} popstate
   * @returns {void}
   */


		/**
   * Stores the current scroll positions for the URL we just came from
   */


		/**
   * Handles `clickLink`
   * @param {PointerEvent}
   * @returns {void}
   */

	}, {
		key: 'maybeResetScrollPositions',


		/**
   * Deletes the scroll positions for the URL a link is pointing to,
   * if shouldResetScrollPosition evaluates to true
   * @param {HTMLAnchorElement} htmlAnchorElement
   * @returns {void}
   */
		value: function maybeResetScrollPositions(htmlAnchorElement) {
			if (!this.options.shouldResetScrollPosition(htmlAnchorElement)) {
				return;
			}
			var url = new _helpers.Link(htmlAnchorElement).getAddress();
			this.resetScrollPositions(url);
		}

		/**
   * Stores the scroll positions for the current URL
   * @param {string} url
   * @returns {void}
   */

	}, {
		key: 'storeScrollPositions',
		value: function storeScrollPositions(url) {
			// retrieve the current scroll position for all containers
			var containers = (0, _utils.queryAll)(this.options.scrollContainers).map(function (el) {
				return {
					top: el.scrollTop,
					left: el.scrollLeft
				};
			});

			// construct the final object entry, with the window scroll positions added
			this.scrollPositionsStore[url] = {
				window: { top: window.scrollY, left: window.scrollX },
				containers: containers
			};
		}

		/**
   * Resets stored scroll positions for a given URL
   * @param {string} url
   */

	}, {
		key: 'resetScrollPositions',
		value: function resetScrollPositions(url) {
			delete this.scrollPositionsStore[url];
			this.scrollPositionsStore[url] = null;
		}

		/**
   * Get the stored scroll positions for a given URL from the cache
   * @returns {(object|null)}
   */

	}, {
		key: 'getStoredScrollPositions',
		value: function getStoredScrollPositions(url) {
			return this.scrollPositionsStore[url];
		}

		/**
   * Restore the scroll positions for all matching scrollContainers
   * @returns void
   */

	}, {
		key: 'restoreScrollContainers',
		value: function restoreScrollContainers(popstate) {
			// get the stored scroll positions from the cache
			var scrollPositions = this.getStoredScrollPositions(this.getCurrentCacheKey()) || {};
			if (scrollPositions.containers == null) {
				return;
			}

			// cycle through all containers on the current page and restore their scroll positions, if appropriate
			(0, _utils.queryAll)(this.options.scrollContainers).forEach(function (el, index) {
				var scrollPosition = scrollPositions.containers[index];
				if (scrollPosition == null) return;
				el.scrollTop = scrollPosition.top;
				el.scrollLeft = scrollPosition.left;
			});
		}
		/**
   * Get the current cache key for the scroll positions.
   * uses `getCurrentUrl` and applies `swup.resolveUrl` if present
   *
   * `swup.resolveUrl` will become available in Swup 3
   *
   * @returns {string}
   */

	}, {
		key: 'getCurrentCacheKey',
		value: function getCurrentCacheKey() {
			var path = (0, _helpers.getCurrentUrl)();
			if (typeof this.swup.resolveUrl === 'function') {
				return this.swup.resolveUrl(path);
			}
			return path;
		}
	}]);

	return ScrollPlugin;
}(_plugin2.default);

exports.default = ScrollPlugin;